<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Event Horizon</title>


<!--    source code at  https://github.com/scottstensland/webgl-3d-animation

         enjoy  Scott Stensland
-->

<script type="text/javascript" src="ui_logic_handler.js"></script>
<script type="text/javascript" src="persistance_handler.js"></script>
<script type="text/javascript" src="common/gl-matrix.1.3.7.js"></script>
<script type="text/javascript" src="common/common.js"></script>
<script type="text/javascript" src="common/vec3.js"></script>
<script type="text/javascript" src="common/webgl-utils.js"></script>
<script type="text/javascript" src="common/Common_Utils.js"></script>
<script type="text/javascript" src="borg.js"></script>
<script type="text/javascript" src="fish_N_sharks.js"></script>
<script type="text/javascript" src="schwartz_surface.js"></script>
<script type="text/javascript" src="chladni.js"></script>
<script type="text/javascript" src="trefoil_knot.js"></script>
<script type="text/javascript" src="audio_display.js"></script>
<script type="text/javascript" src="webaudio_tooling.js"></script>
<script type="text/javascript" src="audio_process.js"></script>
<script type="text/javascript" src="communication_sockets.js"></script>
<script type="text/javascript" src="landscape.js"></script>
<script type="text/javascript" src="render_to_texture.js"></script>

<!-- <ul id="control_checkboxes"></ul>  -->
<!-- <div id="control_checkboxes"></div> -->

<!-- //  render to texture shaders  // -->

<script id="vertex_shader_render_to_texture" type="x-shader/x-vertex">

    attribute vec3 aVertexPosition;
    attribute vec2 aTextureCoord;

    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;

    varying vec2 vTextureCoord;

    void main(void) {
        gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
        vTextureCoord = aTextureCoord;
    }
</script>
<script id="fragment_shader_render_to_texture" type="x-shader/x-fragment">

    precision mediump float;

    varying vec2 vTextureCoord;

    uniform sampler2D uSampler;

    void main(void) {

        gl_FragColor = texture2D(uSampler, vTextureCoord);
    }

</script>

<!-- //  shader set I  // -->

<script id="vertex_shader_landscape" type="x-shader/x-vertex">

attribute vec3 aVertexPosition;
attribute vec4 aVertexColor;

uniform mat4 uMVMatrix;
uniform mat4 uPMatrix;

uniform float given_point_size;

varying vec4 vColor;

uniform vec2 u_resolution;

uniform float u_time;
varying float v_time;

void main(void) {

    v_time = u_time;

    gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);

    vColor = aVertexColor;

    // gl_PointSize = 0.8;  // minute
    // gl_PointSize = 50.0;    // OK for 2X2
    // gl_PointSize = 20.0;
    // gl_PointSize = 3.0;
    gl_PointSize = given_point_size;     // OK for board size 400
    // gl_PointSize = 0.50;     // OK for board size 400
}



/*
attribute vec3 aVertexPosition;
attribute vec4 aVertexColor;

uniform mat4 uMVMatrix;
uniform mat4 uPMatrix;

uniform float given_point_size;

varying vec4 vColor;

uniform vec2 u_resolution;

uniform float u_time;

// ---

vec3 mod289(vec3 x)
{
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec4 mod289(vec4 x)
{
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}


vec4 permute(vec4 x)
{
  return mod289(((x*34.0)+1.0)*x);
}

vec4 taylorInvSqrt(vec4 r)
{
  return 1.79284291400159 - 0.85373472095314 * r;
}

vec3 fade(vec3 t) {
  return t*t*t*(t*(t*6.0-15.0)+10.0);
}


// Classic Perlin noise, periodic variant
float pnoise(vec3 P, vec3 rep)
{
  vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period
  vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period
  Pi0 = mod289(Pi0);
  Pi1 = mod289(Pi1);
  vec3 Pf0 = fract(P); // Fractional part for interpolation
  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0
  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
  vec4 iy = vec4(Pi0.yy, Pi1.yy);
  vec4 iz0 = Pi0.zzzz;
  vec4 iz1 = Pi1.zzzz;

  vec4 ixy = permute(permute(ix) + iy);
  vec4 ixy0 = permute(ixy + iz0);
  vec4 ixy1 = permute(ixy + iz1);

  vec4 gx0 = ixy0 * (1.0 / 7.0);
  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
  gx0 = fract(gx0);
  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
  vec4 sz0 = step(gz0, vec4(0.0));
  gx0 -= sz0 * (step(0.0, gx0) - 0.5);
  gy0 -= sz0 * (step(0.0, gy0) - 0.5);

  vec4 gx1 = ixy1 * (1.0 / 7.0);
  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
  gx1 = fract(gx1);
  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
  vec4 sz1 = step(gz1, vec4(0.0));
  gx1 -= sz1 * (step(0.0, gx1) - 0.5);
  gy1 -= sz1 * (step(0.0, gy1) - 0.5);

  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);

  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
  g000 *= norm0.x;
  g010 *= norm0.y;
  g100 *= norm0.z;
  g110 *= norm0.w;
  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
  g001 *= norm1.x;
  g011 *= norm1.y;
  g101 *= norm1.z;
  g111 *= norm1.w;

  float n000 = dot(g000, Pf0);
  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
  float n111 = dot(g111, Pf1);

  vec3 fade_xyz = fade(Pf0);
  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); 
  return 2.2 * n_xyz;
}


// makes a pseudorandom number between 0 and 1 


float get_random(float n) { 

    return fract(sin(n)*93942.234); 
} 


void main(void) {

    // gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);

    float move_factor = 100;
    // float seed_value = 4.0;

    // float curr_random = get_random(4.0) * move_factor;
    // float curr_random = sin(u_time/20000.0) * move_factor;

    int mod_time = u_time % 100;

    float local_time = mod_time / move_factor;


    // float half_curr_random = curr_random / 2.0;

    // vec3 mod_vertex_position = aVertexPosition + curr_random - half_curr_random;
    vec3 mod_vertex_position = vec3(sin(local_time)*aVertexPosition.x,
                                    sin(local_time)*aVertexPosition.y,
                                    sin(local_time)*aVertexPosition.z);


    gl_Position = uPMatrix * uMVMatrix * vec4(mod_vertex_position, 1.0);

    vColor = aVertexColor;

    // gl_PointSize = 0.8;  // minute
    // gl_PointSize = 50.0;    // OK for 2X2
    // gl_PointSize = 20.0;
    // gl_PointSize = 3.0;
    gl_PointSize = given_point_size;     // OK for board size 400
    // gl_PointSize = 0.50;     // OK for board size 400

}
*/

</script>
<script id="fragment_shader_landscape" type="x-shader/x-fragment">

    precision mediump float;

    varying vec4 vColor;

    uniform vec2 resolution;

    varying float v_time;

// ---

float PI=3.14159265358979323846;

float speed = v_time * 0.2975;
// float speed = 55.0 * 0.2975;
float ground_x = 1.0 - 0.325 * sin(PI * speed * 0.25);
float ground_y=1.0;
float ground_z=0.5;


vec2 rotate(vec2 k,float t) {

    return vec2(cos(t)*k.x-sin(t)*k.y,sin(t)*k.x+cos(t)*k.y);
}

/*
float draw_scene(vec3 p)
    {
    float tunnel_m=0.125*cos(PI*p.z*1.0+speed*4.0-PI);
    float tunnel1_p=2.0;
    float tunnel1_w=tunnel1_p*0.225;
    float tunnel1=length(mod(p.xy,tunnel1_p)-tunnel1_p*0.5)-tunnel1_w;  // tunnel1
    float tunnel2_p=2.0;
    float tunnel2_w=tunnel2_p*0.2125+tunnel2_p*0.0125*cos(PI*p.y*8.0)+tunnel2_p*0.0125*cos(PI*p.z*8.0);
    float tunnel2=length(mod(p.xy,tunnel2_p)-tunnel2_p*0.5)-tunnel2_w;  // tunnel2
    float hole1_p=1.0;
    float hole1_w=hole1_p*0.5;
    float hole1=length(mod(p.xz,hole1_p).xy-hole1_p*0.5)-hole1_w;   // hole1
    float hole2_p=0.25;
    float hole2_w=hole2_p*0.375;
    float hole2=length(mod(p.yz,hole2_p).xy-hole2_p*0.5)-hole2_w;   // hole2
    float hole3_p=0.5;
    float hole3_w=hole3_p*0.25+0.125*sin(PI*p.z*2.0);
    float hole3=length(mod(p.xy,hole3_p).xy-hole3_p*0.5)-hole3_w;   // hole3
    float tube_m=0.075*sin(PI*p.z*1.0);
    float tube_p=0.5+tube_m;
    float tube_w=tube_p*0.025+0.00125*cos(PI*p.z*128.0);
    float tube=length(mod(p.xy,tube_p)-tube_p*0.5)-tube_w;          // tube
    float bubble_p=0.05;
    float bubble_w=bubble_p*0.5+0.025*cos(PI*p.z*2.0);
    float bubble=length(mod(p.yz,bubble_p)-bubble_p*0.5)-bubble_w;  // bubble
    return max(min(min(-tunnel1,mix(tunnel2,-bubble,0.375)),max(min(-hole1,hole2),-hole3)),-tube);
    }

void mainImage( out vec4 fragColor, in vec2 fragCoord )
    {
    vec2 position=(fragCoord.xy/iResolution.xy);
    vec2 p=-1.0+2.0*position;
    vec3 dir=normalize(vec3(p*vec2(1.77,1.0),1.0));     // screen ratio (x,y) fov (z)
    //dir.yz=rotate(dir.yz,PI*0.5*sin(PI*speed*0.125)); // rotation x
    dir.zx=rotate(dir.zx,-PI*speed*0.25);               // rotation y
    dir.xy=rotate(dir.xy,-speed*0.5);                   // rotation z
    vec3 ray=vec3(ground_x,ground_y,ground_z-speed*2.5);
    float t=0.0;
    const int ray_n=96;
    for(int i=0;i<ray_n;i++)
        {
        float k=draw_scene(ray+dir*t);
        t+=k*0.75;
        }
    vec3 hit=ray+dir*t;
    vec2 h=vec2(-0.0025,0.002); // light
    vec3 n=normalize(vec3(draw_scene(hit+h.xyx),draw_scene(hit+h.yxy),draw_scene(hit+h.yyx)));
    float c=(n.x+n.y+n.z)*0.35;
    vec3 color=vec3(c,c,c)+t*0.0625;
    fragColor=vec4(vec3(c-t*0.0375+p.y*0.05,c-t*0.025-p.y*0.0625,c+t*0.025-p.y*0.025)+color*color,1.0);
    }
*/

    void main(void) {

        float local_time = v_time;

        vec2 position = (gl_FragCoord.xy / resolution.xy);

        gl_FragColor = vColor;
    }

</script>



<!-- //  shader set I  // -->

<script id="vertex_shader_01" type="x-shader/x-vertex">

    attribute vec3 aVertexPosition;
    attribute vec4 aVertexColor;

    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;

    uniform float given_point_size;

    varying vec4 vColor;

    uniform vec2 u_resolution;

    void main(void) {

        gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);

        vColor = aVertexColor;

        // gl_PointSize = 0.8;  // minute
        // gl_PointSize = 50.0;    // OK for 2X2
        // gl_PointSize = 20.0;
        // gl_PointSize = 3.0;
        gl_PointSize = given_point_size;     // OK for board size 400
        // gl_PointSize = 0.50;     // OK for board size 400
    }

</script>
<script id="fragment_shader_01" type="x-shader/x-fragment">
    precision mediump float;

    varying vec4 vColor;

    uniform vec2 resolution;

    void main(void) {

        gl_FragColor = vColor;
    }

</script>

<!-- //  shader set II  // -->

<script id="vertex_shader_02" type="x-shader/x-vertex">

    // attribute vec3 aVertexPosition;
    // attribute vec4 aVertexColor;

    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;

    uniform float given_point_size;

    varying vec4 vColor;

    uniform vec2 u_resolution;

    // varying vec2 position; 

/*
    void main(void) {

        // gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);

        // position = (aVertexPosition.xy + 1.0) * 0.5;


        // vColor = aVertexColor;

        // gl_PointSize = 0.8;  // minute
        // gl_PointSize = 50.0;    // OK for 2X2
        // gl_PointSize = 20.0;
        // gl_PointSize = 3.0;
        gl_PointSize = given_point_size;     // OK for board size 400
        // gl_PointSize = 0.50;     // OK for board size 400

    }
*/
    // -------- now directly from pixelshader noise vertex shader in mozilla shader editor ---- //

    precision mediump float;

    attribute vec3 aVertexPosition;
    varying vec2 position;

    void main() {

      gl_Position = vec4(aVertexPosition, 1.0);
      position = (aVertexPosition.xy + 1.0) * 0.5;
    }

</script>
<script id="fragment_shader_02" type="x-shader/x-fragment">

    precision mediump float;

    // varying vec4 vColor;

    uniform vec2 resolution;

    // ---

    varying vec2 position;
    float time = 0.5; 

    // void main(void) {

    //     gl_FragColor = vColor;
    // }
    

float hash(float n) { 

    return fract(sin(n)*93942.234); 
} 

// smoothsteps a grid of random numbers at the integers 

float noise(vec2 p) { 

    vec2 w = floor(p); vec2 k = fract(p); k = k*k*(3.-2.*k); 

    // smooth it 

    float n = w.x + w.y*57.; 
    float a = hash(n); 
    float b = hash(n+1.); 
    float c = hash(n+57.);
    float d = hash(n+58.); 

    return mix( mix(a, b, k.x), mix(c, d, k.x), k.y);
} 

// rotation matrix 

mat2 m = mat2(0.6,0.8,-0.8,0.6); 

// fractional brownian motion (i.e. photoshop clouds) 

float fbm(vec2 p) { 

    float f = 0.; 
    
    f += 0.5000*noise(p); 
    p *= 2.02*m; 
    f += 0.2500*noise(p); 
    p *= 2.01*m; 
    f += 0.1250*noise(p); 
    p *= 2.03*m; 
    f += 0.0625*noise(p); 
    f /= 0.9375; 

    return f;
} 

void main() { 

    // relative coordinates 

    vec2 p = vec2(position*6.)*vec2(resolution.x/resolution.y, 1.); 
    float t = time * .009; 

    // calling fbm on itself 

    vec2 a = vec2(fbm(p+t*3.), fbm(p-t*3.+8.1)); 
    vec2 b = vec2(fbm(p+t*4. + a*7. + 3.1), fbm(p-t*4. + a*7. + 91.1)); 

    float c = fbm(b*9. + t*20.); 

    // increase contrast 

    c = smoothstep(0.15,0.98,c); 

    // mix in some color 

    vec3 col = vec3(c); 
    col.rb += b*0.17; 

    gl_FragColor = vec4(col, 1.); 

    // gl_FragColor = vColor;

}


    // ---------------- and now for some noise --------------------- //

    /* 
    Iterated Fractional Brownian Motion Based on: 

    http://www.iquilezles.org/www/articles/warp/warp.htm 
*/ 
/*
precision mediump float; 

varying vec2 position; 
// uniform float time; 
float time = 0.5; 
// uniform vec2 resolution; 

// makes a pseudorandom number between 0 and 1 

float hash(float n) { 

    return fract(sin(n)*93942.234); 
} 

// smoothsteps a grid of random numbers at the integers 

float noise(vec2 p) { 

    vec2 w = floor(p); vec2 k = fract(p); k = k*k*(3.-2.*k); 

    // smooth it 

    float n = w.x + w.y*57.; 
    float a = hash(n); 
    float b = hash(n+1.); 
    float c = hash(n+57.); 
    float d = hash(n+58.); 

    return mix( mix(a, b, k.x), mix(c, d, k.x), k.y); 

} 

// rotation matrix 

mat2 m = mat2(0.6,0.8,-0.8,0.6); 

// fractional brownian motion (i.e. photoshop clouds) 

float fbm(vec2 p) { 

    float f = 0.; 
    
    f += 0.5000*noise(p); 
    p *= 2.02*m; 
    f += 0.2500*noise(p); 
    p *= 2.01*m; 
    f += 0.1250*noise(p); 
    p *= 2.03*m; 
    f += 0.0625*noise(p); 
    f /= 0.9375; 

    return f; 
} 

void main() { 

    // relative coordinates 

    vec2 p = vec2(position*6.)*vec2(resolution.x/resolution.y, 1.); 
    float t = time * .009; 

    // calling fbm on itself 

    vec2 a = vec2(fbm(p+t*3.), fbm(p-t*3.+8.1)); 
    vec2 b = vec2(fbm(p+t*4. + a*7. + 3.1), fbm(p-t*4. + a*7. + 91.1)); 

    float c = fbm(b*9. + t*20.); 

    // increase contrast 

    c = smoothstep(0.15,0.98,c); 

    // mix in some color 

    vec3 col = vec3(c); 
    col.rb += b*0.17; 

    // gl_FragColor = vec4(col, 1.); 

    gl_FragColor = vColor;

}
*/


/*
// precision mediump float;

varying vec2 position;
// uniform float time;
float time = 0.5; 

// uniform vec2 resolution;

// makes a pseudorandom number between 0 and 1
float hash(float n) {
  return fract(sin(n)*93942.234);
}

// smoothsteps a grid of random numbers at the integers
float noise(vec2 p) {
  vec2 w = floor(p);
  vec2 k = fract(p);
  k = k*k*(3.-2.*k); // smooth it
  
  float n = w.x + w.y*57.;
  
  float a = hash(n);
  float b = hash(n+1.);
  float c = hash(n+57.);
  float d = hash(n+58.);
  
  return mix(
    mix(a, b, k.x),
    mix(c, d, k.x),
    k.y);
}

// rotation matrix
mat2 m = mat2(0.6,0.8,-0.8,0.6);

// fractional brownian motion (i.e. photoshop clouds)
float fbm(vec2 p) {
  float f = 0.;
  f += 0.5000*noise(p); p *= 2.02*m;
  f += 0.2500*noise(p); p *= 2.01*m;
  f += 0.1250*noise(p); p *= 2.03*m;
  f += 0.0625*noise(p);
  f /= 0.9375;
  return f;
}

void main() {
  // relative coordinates
  vec2 p = vec2(position*6.)*vec2(resolution.x/resolution.y, 1.);
  float t = time * .009;
  
  // calling fbm on itself
  vec2 a = vec2(fbm(p+t*3.), fbm(p-t*3.+8.1));
  vec2 b = vec2(fbm(p+t*4. + a*7. + 3.1), fbm(p-t*4. + a*7. + 91.1));
  float c = fbm(b*9. + t*20.);
  
  // increase contrast
  c = smoothstep(0.15,0.98,c);
  
  // mix in some color
  vec3 col = vec3(c);
  col.rb += b*0.17;
  
  gl_FragColor = vec4(col, 1.);
}
*/

</script>

<script type="text/javascript"  src="webgl_3d_animation.js"></script>

<!-- <label><input type="checkbox" onclick="ui_logic_handler.handleClick('animals_persistance', this);" checked>mongo DB</label> -->


<label><input type="checkbox" onclick="ui_logic_handler.handleClick('toggle_mute', this);" >mute audio</label>

<label><input type="checkbox" onclick="ui_logic_handler.handleClick('animals_audio_vis', this);" checked>audio vis</label>

<label><input type="checkbox" onclick="ui_logic_handler.handleClick('animals_fft', this);" checked>audio fft</label>

<label><input type="checkbox" onclick="ui_logic_handler.handleClick('animals_time_curve', this);" checked>audio time curve</label>

<label><input type="checkbox" onclick="ui_logic_handler.handleClick('animals_borg', this);" checked>borg</label>

<label><input type="checkbox" onclick="ui_logic_handler.handleClick('animals_chladni', this);" checked>chladni</label>

<label><input type="checkbox" onclick="ui_logic_handler.handleClick('animals_pasture', this);" checked>pasture</label>

<label><input type="checkbox" onclick="ui_logic_handler.handleClick('animals_trefoil_knot', this);" checked>trefoil knot</label>

<label><input type="checkbox" onclick="ui_logic_handler.handleClick('animals_schwartz', this);" checked>schwartz</label>

<label><input type="checkbox" onclick="ui_logic_handler.handleClick('animals_fish', this);" checked>fish &amp; sharks</label>

<label><input type="checkbox" onclick="ui_logic_handler.handleClick('animals_doughnut', this);" checked>doughnut</label>


</head>
<body onload="webgl_3d_animation.internal_webGLStart();" >
    <ul id="error_output"></ul> 
    <p>

    <button onclick="webgl_3d_animation.set_camera_perspectives()">reset perspective</button>

        <!-- <input id="volume" type="range" min="0" max="1" step="0.1" value="0.5"/> -->

        <!-- <button onclick="webaudio_tooling_obj.run_synth()">do synth</button> -->
<!--        <button onclick="webaudio_tooling_obj.play_tune_jam(1)">play jam</button>   -->
        <!-- <button onclick="webaudio_tooling_obj.play_tune_jam(2)">play jam looped</button> -->
        <!-- <button onclick="webaudio_tooling_obj.play_tune_jam(3)">play wav buffer</button> -->
        <!-- <button onclick="webaudio_tooling_obj.record_microphone()">rec mic</button> -->

    </p>

    <!-- <canvas id="ecology_simulation" style="border: none;" width="200" height="200"></canvas> -->
    <!-- <canvas id="ecology_simulation" style="border: none;" width="350" height="350"></canvas> -->
    <!-- <canvas id="ecology_simulation" style="border: none;" width="800" height="800"></canvas> -->
    <canvas id="ecology_simulation" style="border: none;" width="1920" height="1080"></canvas>
    <br>
<div id="log_microphone">
</div>
  
</body>
</html>
